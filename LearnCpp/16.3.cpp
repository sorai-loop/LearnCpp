#include<iostream>
#include<vector>

int main() {
	//C++における設計ミス
	//
	// 配列に対する添え字と配列宣言時に示される配列の長さを示すもののデータ型は同一である必要がある
	// →違った場合配列の中に表現できない要素が出来てしまう
	// 
	// size_tについて
	// 整数型を表現するにあたって十分なサイズのバイト数を持った型
	// なぜわざわざこれで定義しているのか？
	// →環境によってサイズが変わる可能性のあるintに対して明確に特定のメモリサイズを定義する存在
	// 
	// signedと暗黙的型変換
	// testcodeのようにsignedとunsignedで比較演算を行うとsignedがunsignedに暗黙的に変換されてしまう
	// 暗黙的型変換では2つの内情報量の多い方に変換される
	// C++では＋−を扱えるsignedよりもunsignedの方が情報量が多いと判断されるため-の値をもつsignedが変換される可能性がある
	// その場合、値はunsignedの最大値の余りとなり、すごい値になる
	// 言語設計の思想としては
	// 符号にとられる容量がない分unsignedの方が広域の値を表現できると考えられ、signed→unsignedでは値は失われないと考えられていた
	// 
	// C++は安全な言語であることより一貫した低レベル性をとった
	// 
	// 宣言時にunsignedにしても添え字としてのオペランド[]は符号チェックを持たないため、結局size_tの意味がない
	// 
	// vectorは.size()をsize_tで返してくるのでvectorを使うとunsignedの暗黙的型変換を常に警戒しなくてはいけない
	// そのため、基本的にはsignedを使いsize_tが使用される場合は明示的に型変換を行うべきである。
	// static_cast<int>()で明示的変換
	// 
	// C++20ではssize()を使いことでsinedとして値を返す関数を作れる
	// 
	//	参照は[]か.at()を使用する
	// .at()は境界チェックを行うため、要素が存在しない場合は例外を投げる
	// もし、キャッチしない場合プログラムが終了する
	// 
	// 
	// 
	// 
	//
	std::vector<int> a{ 1,2 };
	a.size();
	//でサイズを見れる


}